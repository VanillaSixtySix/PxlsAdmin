{% extends "master.html.twig" %}

{% set title = 'Pixel Lookup' %}

{% block content %}
    <div class="row">
        <div class="col-xs-12">
            <div class="box">
                <div class="box-header">
                    <h3 class="box-title">Search</h3>
                </div>
                <div class="box-body">
                    <ul class="nav nav-pills nav-justified">
                        <li class="active"><a data-toggle="tab" href="#search-custom">Custom</a></li>
                        <li><a data-toggle="tab" href="#search-by-id">By ID</a></li>
                    </ul>
                    <form name="search" class="tab-content">
                        <p>Leave any fields empty to ignore them.</p>
                        <div id="search-by-id" class="tab-pane">
                            <div class="form-inline">
                                <div class="form-group">
                                    <label for="pixel-id">Pixel ID</label>
                                    <input name="pixel-id" class="form-control" type="number" min="0" />
                                </div>
                            </div>
                        </div>
                        <div id="search-custom" class="tab-pane active">
                            <fieldset class="form-inline">
                                <div class="form-group">
                                    <label for="amount">Limit</label>
                                    <input name="amount" class="form-control" type="number" min="0" value="1000" />
                                </div>
                            </fieldset>
                            <fieldset>
                                <legend>Coordinate</legend>
                                <div>
                                    <label>
                                        <input type="radio" name="coordinate-search-type--toggle" value="range" checked/> Range
                                    </label>
                                    <label>
                                        <input type="radio" name="coordinate-search-type--toggle" value="exact" /> Exact
                                    </label>
                                </div>
                                <div data-section-name="coordinate-search-type" data-section-value="range">
                                    <div>
                                        <div id="coordsFrom"></div>
                                        to
                                        <div id="coordsTo"></div>
                                    </div>
                                </div>
                                <div data-section-name="coordinate-search-type" data-section-value="exact">
                                    <div>
                                        <div id="coordsExact"></div>
                                    </div>
                                </div>
                                <span id="lblCoordinateFeedback" class="help-block text-orange" style="display: none;"><i class="icon fa fa-warning"></i> Invalid</span>
                            </fieldset>
                            <fieldset class="form-inline">
                                <legend>Time range</legend>
                                <div class="form-group">
                                    <input name="timerange-start" class="form-control" type="text" placeholder="YYYY/MM/DD hh:mm:ss A"></input>
                                    to
                                    <input name="timerange-end" class="form-control" type"text" placeholder="YYYY/MM/DD hh:mm:ss A"></input>
                                    <span id="lblBeforeFeedback" class="help-block text-orange" style="display: none;"><i class="icon fa fa-warning"></i> Start date time is invalid</span>
                                    <span id="lblBeforeAfter" class="help-block text-orange" style="display: none;"><i class="icon fa fa-warning"></i> End date time is invalid</span>
                                </div>
                            </fieldset>
                            <fieldset>
                                <legend>Placers</legend>
                                <ul id="lstPlacers"></ul>
                            </fieldset>
                            <fieldset>
                                <legend>Colors</legend>
                                <div id="lstColors" class="color-filter">Loading...</div>
                            </fieldset>
                            <fieldset>
                                <legend>Properties</legend>
                                <div class="form-group">
                                    <div class="checkbox">
                                        <label class="pixel-prop"><input name="mostRecent" type="checkbox" /> Only most recent pixels</label>
                                    </div>
                                    <div class="checkbox">
                                        <label class="pixel-prop"><input name="wasUndone" type="checkbox" /> Only undone pixels</label>
                                    </div>
                                    <div class="checkbox">
                                        <label class="pixel-prop"><input name="undoAction" type="checkbox" /> Only pixels that are part of an undo</label>
                                    </div>
                                    <div class="checkbox">
                                        <label class="pixel-prop"><input name="modAction" type="checkbox" /> Only pixels placed with placement overrides</label>
                                    </div>
                                    <div class="checkbox">
                                        <label class="pixel-prop"><input name="rollbackAction" type="checkbox" /> Only pixels that are part of a rollback</label>
                                    </div>
                                </div>
                            </fieldset>
                        </div>
                        <button id="btnQuery" class="btn btn-primary" disabled>Query</button>
                    </form>
                </div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-xs-12">
            <div class="box">
                <div class="box-header">
                    <h3 class="box-title">Results</h3>
                </div>
                <div class="box-body">
                    <div id="fetch-error-box" class="alert alert-error" style="display: none;">
                        <h4><i class="icon fa fa-times"></i> An error occurred</h4>
                        <span class="alert-error__text"></span><br/>
                        Please contact a developer. The error has been logged.
                    </div>
                    <div>
                        <b>Show fields</b>:
                        <label><input type="checkbox" data-toggle-column="4" checked /> Time</label>
                        <label><input type="checkbox" data-toggle-column="5" checked /> Is Most Recent</label>
                        <label><input type="checkbox" data-toggle-column="6" /> Was Undone</label>
                        <label><input type="checkbox" data-toggle-column="7" /> Is Undo</label>
                        <label><input type="checkbox" data-toggle-column="8" /> With Placement Override</label>
                        <label><input type="checkbox" data-toggle-column="9" /> Is Part of a Rollback</label>
                    </div>
                    <table id="tblPixels" class="table table-responsive table-bordered table-striped nowrap">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Placer</th>
                                <th>Coords</th>
                                <th>Color</th>
                                <th>Time</th>
                                <th>Is Most Recent</th>
                                <th>Was Undone</th>
                                <th>Is Undo</th>
                                <th>With Placement Override</th>
                                <th>Is Part of a Rollback</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                    <div class="btn-group pull-right">
                        <button id="btnExportCSV" class="btn btn-default">Export as CSV</button>
                        <button id="btnExportJSON" class="btn btn-default">Export as JSON</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="row board-preview" style="display: none;">
        <div class="col-xs-12">
            <div class="box">
                <div class="box-header">
                    <h3 class="box-title">Board</h3>
                </div>
                <div class="box-body">
                    <div class="col-sm-3">
                        <p class="board-preview__range text-muted text-center">
                            <span class="board-preview__range__min"></span>
                            <i class="icon fa fa-arrow-right"></i>
                            <span class="board-preview__range__max"></span>
                        </p>
                        <div class="form-group">
                            <button id="btnBoardPreviewDownload" class="btn btn-default">Download as PNG</button>
                        </div>
                        <div class="form-group">
                            <label><input id="cbBoardPreviewBackground" type="checkbox" checked /> Show checkerboard pattern</label>
                        </div>
                        <div class="form-group">
                            <label><input id="cbBoardPreviewUserMode" type="checkbox" /> Color-coded users mode</label>
                            <p class="help-block">Color each pixel by their placer, using the colors defined above.</p>
                        </div>
                    </div>
                    <div class="col-sm-9">
                        <div class="board-preview__rangeslider-container">
                            <input type="text" class="board-preview__rangeslider"></span>
                        </div>
                        <div class="board-preview__layer-container">
                            <canvas class="board-preview__result-layer"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
{% endblock content %}

{% block css %}
    <link rel="stylesheet" href="{{ base_url() }}/assets/plugins/datatables/jquery.dataTables.min.css">
    <link rel="stylesheet" href="{{ base_url() }}/assets/plugins/datatables/dataTables.bootstrap.css">
    <link rel="stylesheet" href="{{ base_url() }}/assets/plugins/ionslider/ion.rangeSlider.min.css">
    {{ parent() }}
    <style>
        fieldset legend {
            margin: 1em 0 0.5em 0;
        }

        .checkerboard-background {
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAIAAAD91JpzAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAVSURBVBhXY1i/fv39+/cZgfjChQsAQicJuS/hrEUAAAAASUVORK5CYII=');
            background-size: cover;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .dynamic-list {
            padding-left: 0;
        }
        ul.dynamic-list > li {
            list-style: none;
        }

        .coordinate-input {
            display: inline-block;
        }
        .coordinate-input::before {
            content: "(";
        }
        .coordinate-input::after {
            content: ")";
        }
        .coordinate-input > input {
            width: 5em;
            padding: 0 0.25em;
            border: none;
            border-bottom: 1px solid #D7D7D7;
        }

        .color-filter > input[type="checkbox"] {
            position: relative;
            margin: 2px;
            width: 2em;
            height: 2em;
            border: 1px solid black;
            appearance: none;
            cursor: pointer;
        }

        .color-filter > input[type="checkbox"]:checked::after {
            position: absolute;
            content: "";
            width: 100%;
            height: 3px;
            bottom: 0;
            background-color: blue;
            box-shadow: 0px -1px 6px black;
        }

        .placer-color {
            position: relative;
            padding: 0;
            margin: 0;
            width: 32px;
        }
        .placer-color > input[type="color"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            padding: 0;
            margin: 0;
            appearance: none;
        }

        .board-preview canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .board-preview__range {
            font-family: monospace;
        }
        .board-preview__layer-container {
            position: relative;
        }
        .board-preview__result-layer {
            width: 100%;
            box-shadow: 0 0 7px 4px rgba(0, 0, 0, .25);
        }
        .board-preview__rangeslider-container {
            margin-bottom: 1em;
        }
    </style>
{% endblock css %}

{% block js %}
    {{ parent() }}
    <script src="{{ base_url() }}/assets/plugins/datatables/jquery.dataTables.min.js"></script>
    <script src="{{ base_url() }}/assets/plugins/datatables/dataTables.bootstrap.min.js"></script>
    <script src="{{ base_url() }}/assets/plugins/datatables/extensions/Scroller/js/dataTables.scroller.js"></script>
    <script src="{{ base_url() }}/assets/plugins/ionslider/ion.rangeSlider.min.js"></script>
    {% if not had_error %}
    <script type="text/javascript">
        (function() {
            $.fn.DynamicList = function(itemModel) {
                const $this = $(this);
                itemModel = Array.isArray(itemModel) ? itemModel : [itemModel];

                const addBtnEl = $('<button class="btn btn-success"> <i class="icon fa fa-plus"/> Add</button>')
                    .on('click', (ev) => {
                        ev.preventDefault();

                        const itemEl = $('<li class="input-group col-sm-4" />')
                            .append(
                                itemModel.map((el) => el.clone(true)),
                                $('<span class="input-group-btn" />')
                                    .append($('<button class="btn btn-danger"><i class="icon fa fa-times"></i></button>')
                                        .on('click', (ev) => {
                                            ev.preventDefault();
                                            itemEl.remove();
                                        })
                                    )
                            );

                        const addEv = new $.Event('itemAdd', {
                            relatedTarget: itemEl[0]
                        });
                        $this.trigger(addEv);

                        if (!addEv.isDefaultPrevented()) {
                            itemEl.insertBefore(addBtnEl);
                        }
                    });

                $this.addClass('dynamic-list');
                $this.append(addBtnEl);

                return $this;
            };

            $.fn.coordinates = function(opts) {
                opts = opts || {};
                const $this = $(this);

                const inputX = $('<input type="number" min="0" />');
                if (opts.placeholderX != null) {
                    inputX.attr('placeholder', opts.placeholderX);
                }
                if (opts.maxX != null) {
                    inputX.attr('max', opts.maxX);
                }

                const inputY = $('<input type="number" min="0" />');
                if (opts.placeholderY != null) {
                    inputY.attr('placeholder', opts.placeholderY);
                }
                if (opts.maxY != null) {
                    inputY.attr('max', opts.maxY);
                }

                inputX.on('keydown', (ev) => {
                    if (ev.key === ',') {
                        ev.preventDefault();
                        inputY.focus();
                    }
                });

                $this.addClass('coordinate-input');
                $this.append(inputX, ', ', inputY);
                $this.val = function() {
                    const xStr = inputX.val();
                    const yStr = inputY.val();
                    if (!xStr && !yStr) {
                        return null;
                    }

                    return [parseInt(xStr), parseInt(yStr)];
                };

                return $this;
            }

            function SectionToggle(name) {
                this.elements = {
                    toggles: $(`input[type="radio"][name="${name}--toggle"]`),
                    sections: $(`[data-section-name="${name}"]`)
                };

                let activeSection = null;

                Object.defineProperty(this, 'activeSection', {
                    get: () => activeSection
                });

                this.update = (value, show) => {
                    if (show) {
                        this.elements.sections.hide();
                        activeSection = value;
                    }
                    this.elements.sections
                        .filter(`[data-section-value="${value}"]`)
                        .toggle(show);
                }

                this.elements.toggles
                    .on('change', (ev) => this.update(ev.target.value, ev.target.checked))
                    .each((idx, el) => this.update(el.value, el.checked));

                return this;
            }

            const utils = {
                saveAs(blob, name) {
                    const a = document.createElement('a');
                    a.download = name || blob.name;
                    a.rel = 'noopener';
                    a.href = URL.createObjectURL(blob);
                    setTimeout(() => URL.revokeObjectURL(a.href), 40 * 1000);
                    setTimeout(() => a.dispatchEvent(new MouseEvent('click')));
                },
                toCSV(data) {
                    if (data.length === 0) {
                        return '';
                    }

                    let result = Object.keys(data[0]).join(',') + '\n';
                    for (const row of data) {
                        result += Object.values(row) + '\n';
                    }
                    return result;
                },
                isValidDate: (d) => !(d === 'Invalid Date' || isNaN(d)),
                isValidCoord: ([x, y]) => !(isNaN(x) || isNaN(y)),
                getPixelBounds: (pixels) => pixels.reduce((acc, { x, y }) => {
                    if (x > acc.max.x) {
                        acc.max.x = x;
                    }
                    if (x < acc.min.x) {
                        acc.min.x = x;
                    }

                    if (y > acc.max.y) {
                        acc.max.y = y;
                    }
                    if (y < acc.min.y) {
                        acc.min.y = y;
                    }

                    return acc;
                }, {
                    min: { x: +Infinity, y: +Infinity },
                    max: { x: -Infinity, y: -Infinity }
                })
            };

            const gameInfo = new (function() {
                this.info = null;

                Object.defineProperty(this, 'hasData', {
                    get: () => {
                        return this.info != null;
                    }
                });

                this.promise = fetch('{{ webroots.game }}/info')
                    .then((res) => res.json())
                    .then((info) => {
                        this.info = info;
                        return info;
                    })
                    .catch((err) => {
                        console.error('Failed to fetch game info', err);
                    });

                return this;
            })();

            const placersList = new (function() {
                this.elements = {
                    lstPlacers: $('#lstPlacers')
                };

                this.getPlacerNames = () => this.elements.lstPlacers.find('input[name="placers[]"]')
                    .map((idx, inp) => inp.value.trim())
                    .filter((idx, name) => name)
                    .toArray();

                this.getPlacerColor = (username) => this.elements.lstPlacers
                    .find('input[name="placers[]"]').filter((idx, el) => el.value === username).first()
                    .parent().find('.placer-color input').val();

                this.list = this.elements.lstPlacers.DynamicList([
                    $('<div class="input-group-addon placer-color" />')
                        .append($('<input type="color" />')),
                    $('<input class="form-control" name="placers[]" placeholder="Username" />')
                ]).on('itemAdd', (ev) => {
                    $(ev.relatedTarget).find('.placer-color input[type="color"]')
                        .val(`#${Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0')}`);
                });

                return this;
            })();

            const colorFilter = new (function() {
                this.elements = {
                    lstColors: $('#lstColors')
                };

                this.getSelectedColorIndices = () => this.elements.lstColors
                    .find('input[type="checkbox"]:checked')
                    .map((idx, inp) => parseInt(inp.dataset.colorIdx))
                    .toArray()

                gameInfo.promise.then(
                    ({ palette }) => {
                        this.elements.lstColors.contents().remove();

                        this.elements.lstColors.append(
                            $(`<input type="checkbox" data-color-idx="255" class="checkerboard-background"/>`)
                        );
                        for (const idx in palette) {
                            const color = palette[idx];
                            this.elements.lstColors.append(
                                $(`<input type="checkbox" />`)
                                    .attr('data-color-idx', idx)
                                    .css('background-color', `#${color.value}`)
                            );
                        }
                    },
                    (err) => {
                        this.elements.lstColors
                            .addClass('text-red')
                            .text('Could not retrieve colors from the game.');
                    }
                );

                return this;
            });

            const search = new (function() {
                this.elements = {
                    form: $('form[name="search"]'),
                    btnQuery: $('#btnQuery'),
                    errorBox: $('#fetch-error-box'),
                    coordsFrom: $('#coordsFrom'),
                    coordsTo: $('#coordsTo'),
                    coordsExact: $('#coordsExact'),
                    lblCoordinateFeedback: $('#lblCoordinateFeedback'),
                    lblBeforeFeedback: $('#lblBeforeFeedback'),
                    lblAfterFeedback: $('#lblAfterFeedback')
                };

                const timerangeStart = $('input[name="timerange-start"]').daterangepicker({
                    singleDatePicker: true,
                    timePicker: true,
                    showDropdowns: true,
                    locale: {
                        format: 'YYYY/MM/DD hh:mm:ss A',
                        cancelLabel: 'Clear'
                    }
                }).on('cancel.daterangepicker', (_, picker) => picker.element.val('')).val('');
                const timerangeEnd = $('input[name="timerange-end"]').daterangepicker({
                    singleDatePicker: true,
                    timePicker: true,
                    showDropdowns: true,
                    locale: {
                        format: 'YYYY/MM/DD hh:mm:ss A',
                        cancelLabel: 'Clear'
                    }
                }).on('cancel.daterangepicker', (_, picker) => picker.element.val('')).val('');

                const coordinateSectionToggle = new SectionToggle('coordinate-search-type');
                const coordsFrom = this.elements.coordsFrom.coordinates({
                    placeholderX: 'from X',
                    placeholderY: 'from Y'
                });
                const coordsTo = this.elements.coordsTo.coordinates({
                    placeholderX: 'to X',
                    placeholderY: 'to Y'
                });
                const coordsExact = this.elements.coordsExact.coordinates({
                    placeholderX: 'x',
                    placeholderY: 'y'
                });

                const getActiveTab = () => this.elements.form.find('.tab-pane.active').first().attr('id');

                this.showError = function() {
                    this.elements.errorBox.show();
                    this.elements.errorBox.find('.alert-error__text').text();
                };

                this.parseInputs = function() {
                    const qs = new URLSearchParams();
                    let invalid = false;

                    switch (getActiveTab()) {
                        case 'search-by-id': {
                            const pixelId = $('input[name="pixel-id"]').val();
                            if (pixelId) {
                                qs.set('pixelId', pixelId);
                            }
                            break;
                        }
                        case 'search-custom': {
                            switch (coordinateSectionToggle.activeSection) {
                                case 'exact': {
                                    const coordsExactVal = coordsExact.val();
                                    if (coordsExactVal != null) {
                                        if (utils.isValidCoord(coordsExactVal)) {
                                            this.elements.lblCoordinateFeedback.hide();

                                            const [ x, y ] = coordsExactVal;
                                            qs.set('coordsX', x);
                                            qs.set('coordsY', y);
                                        } else {
                                            invalid = true;
                                            this.elements.lblCoordinateFeedback.show();
                                        }
                                    }
                                    break;
                                }
                                case 'range': {
                                    const coordsFromVal = coordsFrom.val();
                                    const coordsToVal = coordsTo.val();
                                    if (coordsFromVal != null && coordsToVal != null) {
                                        if (utils.isValidCoord(coordsFromVal) && utils.isValidCoord(coordsToVal)) {
                                            this.elements.lblCoordinateFeedback.hide();

                                            const [ fromX, fromY ] = coordsFromVal;
                                            qs.set('coordsFromX', fromX);
                                            qs.set('coordsFromY', fromY);

                                            const [ toX, toY ] = coordsToVal;
                                            qs.set('coordsToX', toX);
                                            qs.set('coordsToY', toY);
                                        } else {
                                            invalid = true;
                                            this.elements.lblCoordinateFeedback.show();
                                        }
                                    }
                                }
                            }

                            const timerangeEndVal = timerangeEnd.val();
                            if (timerangeEndVal.length > 0) {
                                const beforeDate = new Date(timerangeEndVal);
                                if (utils.isValidDate(beforeDate)) {
                                    this.elements.lblBeforeFeedback.hide();
                                    qs.set('before', beforeDate.getTime());
                                } else {
                                    invalid = true;
                                    this.elements.lblBeforeFeedback.show();
                                }
                            }

                            const timerangeStartVal = timerangeStart.val();
                            if (timerangeStartVal.length > 0) {
                                const afterDate = new Date(timerangeStartVal);
                                if (utils.isValidDate(afterDate)) {
                                    this.elements.lblAfterFeedback.hide();
                                    qs.set('after', afterDate.getTime());
                                } else {
                                    invalid = true;
                                    this.elements.lblAfterFeedback.show();
                                }
                            }

                            const placers = placersList.getPlacerNames();
                            for (const user of placers) {
                                qs.append('placers[]', user);
                            }

                            const colors = colorFilter.getSelectedColorIndices();
                            for (const cIdx of colors) {
                                qs.append('colors[]', cIdx);
                            }

                            $('.pixel-prop input[type="checkbox"]').each((idx, cb) => {
                                if (cb.checked) {
                                    qs.set(cb.name, true)
                                }
                            });

                            qs.set('amount', $('input[name="amount"]').val());
                            break;
                        }
                    }

                    return [qs, invalid];
                };

                this.elements.btnQuery.on('click', (ev) => {
                    ev.preventDefault();
                    ev.target.disabled = true;
                    $('.alert-error').hide();

                    let qs;
                    let invalid;
                    try {
                        [qs, invalid] = this.parseInputs();
                    } catch (err) {
                        this.elements.btnQuery.removeAttr('disabled');
                        this.showError('Failed to parse your query.')
                        console.error('Failed to parse search inputs', err);
                        return;
                    }

                    if (invalid) {
                        this.elements.btnQuery.removeAttr('disabled');
                        return;
                    }

                    fetch(`{{ xhr_base }}/pixels?${qs.toString()}`, {
                        headers: {
                            'Accept': 'application/json'
                        }
                    }).then((res) => res.json()).then((json) => {
                        if (json.status !== 'success') {
                            throw json.error;
                        }

                        // Update table
                        table.setData(json.data)

                        // Update graphs
                        if (gameInfo.hasData && json.data.length > 0) {
                            boardPreview.reinit();
                            boardPreview.elements.row.show();
                        } else {
                            boardPreview.elements.row.hide();
                        }
                    }).catch((err) => {
                        console.error('Failed to execute query', err);
                        this.showError('Failed to retrieve the queried pixels.');
                    }).finally(() => {
                        this.elements.btnQuery.removeAttr('disabled');
                    });
                });

                gameInfo.promise.finally(() => {
                    this.elements.btnQuery.removeAttr('disabled');
                });

                return this;
            })();

            const table = new (function() {
                this.elements = {
                    table: $('#tblPixels'),
                    btnExportAsCSV: $('#btnExportCSV'),
                    btnExportAsJSON: $('#btnExportJSON'),
                    cbColumnToggles: $('input[type="checkbox"][data-toggle-column]')
                };

                const renderBoolean = (data, type, row, meta) => {
                    if (type !== 'display') {
                        return data;
                    }
                    return `<i class="icon fa fa-${data ? 'check' : 'times'}"></i> ${data ? 'Yes' : 'No'}`;
                }

                this.datatable = this.elements.table.DataTable({
                    order: [[4, 'desc']],
                    columns: [
                        { data: "pixel_id" },
                        {
                            data: "user_name",
                            render: (data, type, row, meta) => {
                                if (type !== 'display') {
                                    return data;
                                }
                                return `<a href="/userinfo/${data}">${data}</a>`
                            }
                        },
                        {
                            // coordinates
                            render: (data, type, row, meta) => {
                                const pretty = `(${row.x}, ${row.y})`;
                                if (type !== 'display') {
                                    return pretty;
                                }
                                return `<a href="{{ webroots.game }}/#x=${row.x}&y=${row.y}&scale=50">${pretty}</a>`
                            }
                        },
                        {
                            data: "color",
                            render: (data, type, row, meta) => {
                                if (type !== 'display') {
                                    return data;
                                }
                                const isInsidePalette = gameInfo.hasData && data >= 0 && data < gameInfo.info.palette.length;
                                const isTransparent = data === 0xFF;
                                const color = gameInfo.hasData && gameInfo.info.palette[data];
                                return `<div class="pixel-color"${isInsidePalette ? ` style="background-color: #${color.value}"` : ''}></div> ${isInsidePalette ? color.name : (isTransparent ? 'Transparent' : '???')} (${data})`
                            }
                        },
                        { data: "time" },
                        { data: "most_recent", class: 'dt-center', render: renderBoolean },
                        { data: "undone", class: 'dt-center', render: renderBoolean },
                        { data: "undo_action", class: 'dt-center', render: renderBoolean },
                        { data: "mod_action", class: 'dt-center', render: renderBoolean },
                        { data: "rollback_action", class: 'dt-center', render: renderBoolean }
                    ]
                });

                this.getData = () => this.datatable.data();
                this.setData = (data) => {
                    this.datatable.clear();
                    this.datatable.rows.add(data);
                    this.datatable.draw();
                };

                this.elements.cbColumnToggles.on('change', (ev) => {
                    const column = parseInt(ev.target.dataset.toggleColumn);
                    this.datatable.column(column).visible(ev.target.checked);
                }).change();

                this.elements.btnExportAsCSV.on('click', () => {
                    const blob = new Blob(
                        [ utils.toCSV(this.getData().toArray()) ],
                        { type: 'text/csv' }
                    );
                    utils.saveAs(blob, 'pixels.csv');
                });
                this.elements.btnExportAsJSON.on('click', () => {
                    const blob = new Blob(
                        [ JSON.stringify(this.getData().toArray()) + '\n' ],
                        { type: 'application/json' }
                    );
                    utils.saveAs(blob, 'pixels.json');
                });

                return this;
            })();

            const boardPreview = new (function() {
                this.elements = {
                    row: $('.board-preview'),
                    resultCanvas: $('.board-preview__result-layer'),
                    inpRangeSlider: $('.board-preview__rangeslider'),
                    txtPreviewRangeMin: $('.board-preview__range .board-preview__range__min'),
                    txtPreviewRangeMax: $('.board-preview__range .board-preview__range__max'),
                    cbCheckerboardBackground: $('#cbBoardPreviewBackground'),
                    cbUserColorMode: $('#cbBoardPreviewUserMode'),
                    btnDownload: $('#btnBoardPreviewDownload')
                };

                this.ctx = this.elements.resultCanvas[0].getContext('2d');

                this.updateCanvas = (from, to) => {
                    const data = table.getData()
                        .filter(({ pixel_id }) => pixel_id >= from && pixel_id <= to)
                        .toArray();

                    const { min: topLeft, max: bottomRight } = utils.getPixelBounds(data);

                    this.elements.txtPreviewRangeMin.text(`(${topLeft.x}, ${topLeft.y})`);
                    this.elements.txtPreviewRangeMax.text(`(${bottomRight.x}, ${bottomRight.y})`);

                    const width = bottomRight.x - topLeft.x + 1;
                    const height = bottomRight.y - topLeft.y + 1;
                    this.ctx.canvas.width = width;
                    this.ctx.canvas.height = height;
                    this.ctx.canvas.style.backgroundSize = `${Math.max(1, 100 / width)}%`;

                    if (width > 0 && height > 0) {
                        const id = this.ctx.getImageData(0, 0, width, height);

                        const userColorMode = this.elements.cbUserColorMode[0].checked;
                        const userToColor = {};
                        for (const pix of data) {
                            const idx = ((pix.x - topLeft.x) + (pix.y - topLeft.y) * width) * 4;
                            if (id.data[idx + 3] !== 0) {
                                // pixel already drawn
                                continue;
                            }

                            let a = 255;
                            let c = 0;
                            if (userColorMode) {
                                // color with user map
                                if (!(pix.user_name in userToColor)) {
                                    const hex = placersList.getPlacerColor(pix.user_name);
                                    userToColor[pix.user_name] = hex == null ? null : parseInt(hex.substr(1), 16);
                                }

                                c = userToColor[pix.user_name];
                            } else {
                                // color with palette
                                if (pix.color >= 0 && pix.color < gameInfo.info.palette.length) {
                                    c = parseInt(gameInfo.info.palette[pix.color].value, 16);
                                } else if (pix.color === 0xFF) {
                                    a = 0x7F; // half transparency
                                }
                            }

                            if (c == null) {
                                continue;
                            }

                            id.data[idx  ] = c >> 16 & 0xFF;
                            id.data[idx+1] = c >> 8 & 0xFF;
                            id.data[idx+2] = c & 0xFF;
                            id.data[idx+3] = a;
                        }

                        this.ctx.putImageData(id, 0, 0);
                    }
                };


                const handleRangeSliderUpdate = (ev) => this.updateCanvas(ev.to_value, ev.from_value);

                let rangeSliderDebouncingTimeout;
                const rangeSlider = this.elements.inpRangeSlider.ionRangeSlider({
                    skin: 'round',
                    type: 'double',
                    force_edges: true,
                    prettify: (pixelID) => `ID #${pixelID}`,
                    onUpdate: (ev) => this.updateCanvas(ev.from_value, ev.to_value),
                    onChange: (ev) => {
                        if (rangeSliderDebouncingTimeout != null) {
                            clearTimeout(rangeSliderDebouncingTimeout);
                        }
                        rangeSliderDebouncingTimeout = setTimeout(() => this.updateCanvas(ev.from_value, ev.to_value), 100);
                    }
                }).data('ionRangeSlider');

                this.reinit = () => {
                    const data = table.getData()
                        .toArray()
                        .sort(() => 1); // reverse - oldest pixels first

                    const values = data.map(({ pixel_id }) => pixel_id);
                    rangeSlider.update({
                        values,
                        from: 0,
                        to: values.length
                    });
                }

                this.elements.btnDownload.on('click', () => {
                    const fileName = `pixels${gameInfo.hasData ? `-canvas_${gameInfo.info.canvasCode}` : ''}-pixels_${rangeSlider.result.from_value}_to_${rangeSlider.result.to_value}.png`;
                    this.ctx.canvas.toBlob((blob) => utils.saveAs(blob, fileName));
                });
                this.elements.cbCheckerboardBackground.on('change', (ev) => {
                    this.ctx.canvas.classList.toggle('checkerboard-background', ev.target.checked)
                }).change();
                this.elements.cbUserColorMode.on('change', () => {
                    this.updateCanvas(rangeSlider.result.from_value, rangeSlider.result.to_value);
                });

                return this;
            })();
        })();
    </script>
    {% endif %}
{% endblock %}
